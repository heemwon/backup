<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
    <base href="../../../" />
    <link rel="icon" href="assets/favicon.ico" />
    <script src="assets/js/ie.js"></script>
    <link rel="stylesheet" href="assets/css/library/choices.min.css" />
    <link rel="stylesheet" href="assets/css/reset.css" />
    <link rel="stylesheet" href="assets/css/common.css" />
    <link rel="stylesheet" href="assets/css/style.css" />
    <!-- START : 수정 : 210701 title명 수정 -->
    <title>Samsung Cloud Platform</title>
    <!-- END : 수정 : 210701 title명 수정 -->
  </head>
  <body>
    <div class="wrap tech-guide">
      <!-- 3depth 메뉴가 있을 시 header태그에 subpage 듀얼클래스를 추가해주세요. -->
      <div id="header-template" class="header-include subpage"></div>
      <article class="content">
        <div class="hero-sub">
          <div class="content">
            <div class="sub-content">
              <h2 class="font-heading1" data-i18n="label.label_76"></h2>
              <a
                data-i18n="[href]pdf.pdf_56"
                target="_blank"
                class="btn-border large"
                ><i class="ico-link"></i><span class="i18n-inherit" data-i18n="button.button_3"></span></a
              >
            </div>
          </div>
          <div class="visual-tab">
            <nav>
              <ul class="tablist">
                <li><a href="javascript:;" data-scroll-anchor data-i18n="category.category_18"></a></li>
                <li><a href="javascript:;" data-scroll-anchor>NETFILTER가 제공하는 HOOK POINT</a></li>
                <li><a href="javascript:;" data-scroll-anchor>IPTABLES 동작 원리</a></li>
                <li><a href="javascript:;" data-scroll-anchor>테이블</a></li>
                <li><a href="javascript:;" data-scroll-anchor>체인</a></li>
                <li><a href="javascript:;" data-scroll-anchor>패킷 흐름도</a></li>
                <li><a href="javascript:;" data-scroll-anchor>IPTABLES 룰</a></li>
                <li><a href="javascript:;" data-scroll-anchor>타겟</a></li>
                <li><a href="javascript:;" data-scroll-anchor>POLICY CHAIN DEFAULT BEHAVIOR</a></li>
              </ul>
              <span class="progress-bar"></span>
            </nav>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2" data-i18n="category.category_18"></h3>
              <div class="column-box">
                이 문서에서는 iptables 동작 원리의 바탕이 되는 Netfilter 라는 프레임워크와 기본적인 iptables 사용법에 대해 다뤄보겠습니다.
                <br /><br />
                iptables 를 이용해서 리눅스의 방화벽 기능이 동작되게 하는 것은 실제로는 iptables 가 아니라, Netfilter 라는 리눅스 커널에
                이미 내장되어 있는 프레임워크 덕분입니다. Netfilter 를 주로 패킷 필터링 프레임워크(Packet Filtering Framework)라고 부르는데,
                말 그대로 패킷을 필터링할 수 있는 뼈대를 제공한다고 이해하면 됩니다.
                <br /><br />
                즉, Netfilter 자체가 패킷 필터링을 구현해서 모든 규칙을 다 가지고 있는 것은 아니고, iptables 라는 User-Space 에서 실행되는
                툴을 제공하고, 이 툴을 사용해 룰을 추가하면, 패킷이 리눅스 커널에 들어와서 Netfilter 가 정해놓은 각 지점을 통과할 때 미리
                정해진 룰들이 있으면, Netfilter 가 패킷이 그 룰들을 거치게 만들어서 drop 또는 accept 등으로 동작하게 합니다.
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">Netfilter가 제공하는 Hook point</h3>
              <div class="column-box">
                Netfilter 는 5개의 Hook point 를 제공합니다. 패킷들이 각 지점을 통과하면서 각 Hook point 에 등록된 커널 모듈을 트리거하게
                됩니다.
                <br /><br />
                동일 Hook point 에 복수 개의 커널 모듈을 등록해서 사용할 수 있으므로, 커널 모듈이 Hook point 를 잡아서 쓰겠다고 등록할 때
                Priority Number 를 입력해서 그 우선 순위대로 커널 모듈을 트리거하게 됩니다.
                <ul class="list-type6 bullet-none">
                  <li>
                    <strong class="title">NF_IP_PRE_ROUTING</strong>
                    <ul class="list">
                      <li>
                        외부에서 온 패킷이 리눅스 커널의 네트워크 스택에 들어온 직후에 발생하는 Hook입니다. 패킷을 라우팅하기 전에
                        발생합니다.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">NF_IP_LOCAL_IN</strong>
                    <ul class="list">
                      <li>패킷이 라우팅된 후 목적지가 자신일 경우, 패킷을 로컬 프로세스에 전달하기 전에 발생하는 Hook입니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">NF_IP_FORWARD</strong>
                    <ul class="list">
                      <li>패킷이 라우팅된 후 목적지가 자신이 아닐 경우, 패킷을 다른 곳으로 Forwarding하는 경우 발생하는 Hook입니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">NF_IP_LOCAL_OUT</strong>
                    <ul class="list">
                      <li>패킷이 프로세스에서 나와 네트워크 스택을 통과하기 전에 발생하는 Hook입니다.</li>
                    </ul>
                  </li>
                  <li class="margin-bottom">
                    <strong class="title">NF_IP_POST_ROUTING</strong>
                    <ul class="list">
                      <li>패킷이 네트워크 스택을 통과한 후 밖으로 보내기 전 발생하는 Hook입니다.</li>
                    </ul>
                  </li>
                </ul>
                위 5 개의 Hook point 를 그림으로 나타내면 다음과 같습니다.
                <figure class="margin-bottom">
                  <img src="assets/images/img/img_w_ip_f1_1_5_23.jpg" alt="Figure 1. Netfilter 패킷 경로" />
                  <figcaption class="explan-footer">Figure 1. Netfilter 패킷 경로</figcaption>
                </figure>
                위 그림은 Netfilter 에서 패킷의 경로를 나타내고 있습니다.
                <br /><br />
                Routing1 은 NIC(Network Interface Card)에서 전달받은 패킷이 로컬 프로세스가 받아야 하는 패킷인지, 아니면 다른 호스트가
                받아야 하는 패킷인지 구분하여 라우팅하는 과정을 나타냅니다.<br />
                Routing2 는 프로세스에서 전송한 패킷이 NF_IP_LOCAL_OUT 에서 DNAT 될 경우 다시 라우팅하는 과정을 나타냅니다.
                <br /><br />
                정리하면, 패킷 경로는 아래의 3 가지로 구분할 수 있습니다.
                <ul class="list-type6 bullet-none">
                  <li>
                    <strong class="title">외부에서 온 패킷의 목적지가 자신인 경우</strong>
                    <ul class="list">
                      <li>NF_IP_PRE_ROUTING -> NF_IP_LOCAL_IN -> Process</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">외부에서 온 패킷의 목적지가 자신이 아닌 경우</strong>
                    <ul class="list">
                      <li>NF_IP_PRE_ROUTING -> NF_IP_FORWARD -> NF_IP_POST_ROUTING -> Network Interface</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">로컬 프로세스에서 전송하는 패킷의 경우</strong>
                    <ul class="list">
                      <li>NF_IP_LOCAL_OUT -> NF_IP_POST_ROUTING -> Network Interface</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">iptables 동작 원리</h3>
              <div class="column-box">
                iptables 에 의한 패킷 필터링 메커니즘을 이해하기 위해서는 아래 네 가지 용어 또는 구조를 이해해야 합니다.<br />
                - tables, chains, rules, targets
                <br /><br />
                테이블(tables)은 이미 커널에 만들어져 있고 5개가 있습니다. 각 테이블에는 미리 정의된 체인(chain)들이 있고, 이 체인에
                룰(rule)들이 들어가게 됩니다. 룰에는 타겟(target)을 정하게 되어 있는데, 어떤 패킷이 해당 룰에 일치(match)하면 그 타겟으로
                가서 다시 다른 룰에 일치하는지 검사하거나,drop이나 accept 등의 동작을 할 수 있습니다.
                <br /><br />
                그럼 각 구조에 대해서 좀 더 알아보겠습니다.
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">테이블</h3>
              <div class="column-box">
                다음과 같이 총 5가지의 테이블을 제공합니다.
                <ul class="list-type6 bullet-number">
                  <li>
                    <strong class="title">Filter Table</strong>
                    <ul class="list bullet-none">
                      <li>
                        패킷 필터링을 위한 테이블입니다. 패킷을 원래 목적지까지 전달할지, 아니면 drop할지를 결정합니다. Firewall 기능은
                        Filter Table을 통해 구축할 수 있습니다.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">Mangle Table</strong>
                    <ul class="list bullet-none">
                      <li>
                        패킷의 IP 헤더를 바꾸는데 사용됩니다. 예를 들어, 패킷의 TTL(Time to Live)을 변경하거나 패킷을 Marking하여 다른
                        iptables의 테이블이나 네트워크 툴에서 패킷을 구분할 수 있도록 할 수 있습니다.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">NAT Table</strong>
                    <ul class="list bullet-none">
                      <li>
                        패킷 NAT(Network Address Translation)를 위한 테이블입니다. 패킷의 Source Address나 Destination Address를 변경합니다.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">Raw Table</strong>
                    <ul class="list bullet-none">
                      <li>
                        Netfilter 프레임워크는 Hook 뿐만 아니라 Connection Tracking 기능을 제공합니다. 이전에 도착한 패킷들을 바탕으로 방금
                        도착한 패킷의 Connection을 추적합니다. Raw Table은 특정 패킷이 Connection Tracking에서 제외되도록 설정합니다.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">Security Table</strong>
                    <ul class="list bullet-none">
                      <li>SELinux에서 패킷을 어떻게 처리할지 결정하기 위한 테이블입니다.</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">체인</h3>
              <div class="column-box">
                각 테이블에는 빌트인(built-in) 체인들이 있고, 이 체인들의 이름은 Netfilter Hook 이름을 따와서 만들었습니다.
                <ul class="list-type6 bullet-number">
                  <li>
                    <strong class="title">PREROUTING</strong>
                    <ul class="list bullet-none">
                      <li>NF_IP_PRE_ROUTING Hook이 트리거합니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">INPUT</strong>
                    <ul class="list bullet-none">
                      <li>NF_IP_LOCAL_IN Hook이 트리거합니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">FORWARD</strong>
                    <ul class="list bullet-none">
                      <li>NF_IP_FORWARD Hook이 트리거합니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">OUTPUT</strong>
                    <ul class="list bullet-none">
                      <li>NF_IP_LOCAL_OUT Hook이 트리거합니다.</li>
                    </ul>
                  </li>
                  <li>
                    <strong class="title">POSTROUTING</strong>
                    <ul class="list bullet-none">
                      <li>NF_IP_POST_ROUTING Hook이 트리거합니다.</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">패킷 흐름도</h3>
              <div class="column-box">
                iptables 에서 패킷의 경로는 다음과 같습니다.
                <figure class="margin-bottom">
                  <img src="assets/images/img/img_w_ip_f2_1_5_23.jpg" alt="패킷 흐름도" />
                  <figcaption class="explan-footer">Figure 2. iptables 패킷 경로</figcaption>
                </figure>
                위 그림처럼 패킷들은 각 Hook 에서 여러 테이블들을 통과하면서 처리됩니다. 물론 각 테이블에는 여러 체인들이 있고, 각 체인에
                룰이 등록되는데, 패킷이 어떤 룰에 매칭되어서 그 운명이 결정된다면(예를 들어, accept 또는 drop), 다음 체인 또는 테이블로
                진행하지 않습니다.
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">iptables 룰</h3>
              <div class="column-box">
                룰은 특정 테이블의 특정 체인에 등록되어 있고, 각 체인들이 호출될 때 패킷이 등록된 룰과의 매치 여부를 확인한 후 액션을
                결정합니다.
                <br /><br />
                룰의 매치 기준으로는 프로토콜 타입, 출발지 주소/포트, 목적지 주소/포트, input/output interface 등의 조합이 될 수 있습니다.
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">타겟</h3>
              <div class="column-box">
                타겟은 패킷이 등록한 룰과 매치되었을 때 트리거되는 액션입니다.
                <br /><br />
                타겟은 -j 또는 —jump 옵션을 사용합니다. 타겟은 사용자 정의 체인(User-defined Chain)이거나, 빌트인 타겟 중의 하나이거나, 타겟
                확장(extension)일 수 있습니다. 사용자 정의 체인인 경우에는 그 지정된 사용자 정의 체인으로 점프해서 룰 매칭 여부를 계속
                시도합니다. <br />
                빌트인 타겟은 ACCEPT, DROP, QUEUE, RETURN 이 있는데 다음과 같습니다.
                <ol class="list-type4 bullet-number margin-bottom">
                  <li>
                    <p class="desc">ACCEPT - iptables가 패킷을 받아들입니다.</p>
                  </li>
                  <li>
                    <p class="desc">
                      DROP - iptables가 패킷을 버립니다. 시스템에 연결하려는 사람에게는 시스템이 존재하지 않는 것처럼 보입니다.
                    </p>
                  </li>
                  <li>
                    <p class="desc">QUEUE - iptables는 패킷을 userspace로 전달합니다.</p>
                  </li>
                  <li>
                    <p class="desc">
                      RETURN - iptables는 이 패킷에 대한 현재 체인의 다음 규칙 세트 실행을 중지합니다. 컨트롤은 호출 체인으로 반환됩니다.
                    </p>
                  </li>
                </ol>
                타겟 확장으로는 REJECT, LOG 가 있습니다.
                <ol class="list-type4 bullet-number margin-bottom">
                  <li>
                    <p class="desc">
                      REJECT: iptables는 패킷을 “거부”합니다. TCP의 경우 “connection reset” 패킷을, UDP 또는 ICMP의 경우 “destination host
                      unreachable” 패킷을 보냅니다. (위 빌트인 타겟인 DROP 과 차이가 있음)
                    </p>
                  </li>
                </ol>
                만약, 타겟이 빌트인 타겟이면 패킷의 운명이 바로 결정되기 때문에 현재 테이블에서의 패킷 처리는 더 이상 진행하지 않습니다.
                <br /><br />
                만약, 타겟이 사용자 정의 체인이고 패킷의 운명이 이 사용자 정의 체인에 의해 결정되지 않는다면, 다시 원래 체인으로 돌아와서
                나머지 룰과의 매칭을 시도하게 됩니다.
              </div>
            </div>
          </div>
        </div>
        <div class="right-layout" data-scroll-section>
          <div class="left-content">
            <div class="detail-content">
              <h3 class="font-heading2">Policy Chain Default Behavior</h3>
              <div class="column-box">
                위에서 언급한 각 체인들에 룰들이 추가된다고 했을 때, 만약 패킷이 어떤 룰에도 매칭되지 않으면 어떻게 처리할 것인지를 정해야
                합니다.
                <div class="table-wrap full-table margin-bottom">
                  <div class="table-scroll-wrap">
                    <table>
                      <colgroup>
                        <col width="35%" />
                        <col width="55%" />
                      </colgroup>
                      <thead>
                        <tr>
                          <th>Options</th>
                          <th>Description</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td>-N (--new-chain)</td>
                          <td class="left">새로운 체인 추가</td>
                        </tr>
                        <tr>
                          <td>-F (--flush)</td>
                          <td class="left">해당 체인의 모든 rule 삭제</td>
                        </tr>
                        <tr>
                          <td>-P (--policy)</td>
                          <td class="left">정책 변경</td>
                        </tr>
                        <tr>
                          <td>-R (--replace)</td>
                          <td class="left">Rule 을 교체</td>
                        </tr>
                        <tr>
                          <td>-A (--append)</td>
                          <td class="left">새로운 rule 추가</td>
                        </tr>
                        <tr>
                          <td>-I (--insert)</td>
                          <td class="left">새로운 rule 삽입</td>
                        </tr>
                        <tr>
                          <td>-X (--delete-chain)</td>
                          <td class="left">빈 체인 삭제</td>
                        </tr>
                        <tr>
                          <td>-L (--list)</td>
                          <td class="left">테이블에 정의된 rule 확인</td>
                        </tr>
                        <tr>
                          <td>-D (--delete)</td>
                          <td class="left">Rule 삭제</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
                현재 정책을 보려면 아래와 같이 수행합니다.
                <div class="code-wrap margin-bottom">
&#36; sudo iptables -L &#124; grep policy
Chain INPUT (policy ACCEPT)
Chain FORWARD (policy ACCEPT)
Chain OUTPUT (policy ACCEPT)
                </div>
                iptables 명령어에서 ­t 옵션으로 테이블을 지정하지 않으면 디폴트 값이 filter table 이므로 다른 테이블(예: nat)의 체인들에
                대한 디폴트 정책을 알고 싶으면 아래와 같이 수행합니다.
                <div class="code-wrap margin-bottom">
&#36; sudo iptables ­t nat ­L &#124; grep policy
                </div>
                만약, 테이블의 각 체인들에 대한 디폴트 정책을 변경하고 싶으면 아래와 같이 -P 옵션을 사용합니다.
                <br /><br />
                다음은 디폴트 값으로 모든 패킷에 대해 accept 일 경우입니다.
                <div class="code-wrap margin-bottom">
&#36; sudo iptables -P INPUT ACCEPT
&#36; sudo iptables -P OUTPUT ACCEPT
&#36; sudo iptables -P FORWARD ACCEPT
                </div>
                다음은 디폴트 값으로 모든 패킷에 대해 drop 일 경우입니다.
                <div class="code-wrap margin-bottom">
&#36; sudo iptables -P INPUT DROP
&#36; sudo iptables ­P OUTPUT DROP
&#36; sudo iptables -P FORWARD DROP
                </div>
                현재 룰을 확인하기 위해서는 다음의 명령을 수행합니다.
                <div class="code-wrap margin-bottom">
&#36; sudo iptables ­L
&#36; sudo iptables -S
                </div>
                체인의 끝에 룰을 추가하기(-A (—append)) 위해서는 다음의 명령을 수행합니다.
                <div class="code-wrap margin-bottom">&#36; sudo iptables -A</div>
                체인의 특정 위치에 룰을 삽입(-I(—insert)) 하려면 다음의 명령을 수행합니다.
                <div class="code-wrap margin-bottom">&#36; sudo iptables -I</div>
                룰을 교체(-R(—replace))하려면 다음의 명령을 수행합니다.
                <div class="code-wrap margin-bottom">&#36; sudo iptables -R</div>
                룰을 삭제(-D(—delete))하려면 다음의 명령을 수행합니다.
                <div class="code-wrap margin-bottom">&#36; sudo iptables -D</div>
                이상으로 Netfilter 에 대한 개념과 iptables 를 활용한 다양한 사용방법에 대해 살펴봤습니다. 클라우드 환경에서 가상 서버의
                완벽한 네트워크 라우팅 설정에 도움이 되길 바랍니다.
              </div>
            </div>
          </div>
        </div>
      </article>
      <div id="footer-template"></div>
    </div>
    <script src="assets/js/library/jquery.min.js"></script>
    <script src="assets/js/library/swiper-bundle.min.js"></script>
    <script src="assets/js/library/scroll-lock.min.js"></script>
    <script src="assets/js/library/ScrollMagic.min.js"></script>
    <script src="assets/js/library/choices.min.js"></script>
    <script src="assets/js/library/i18next-1.11.2.min.js"></script>

    <script src="assets/js/common.js"></script>
    <script src="assets/js/i18n.js"></script>
    <script src="assets/js/initialize.js"></script>
    <script src="assets/js/pub.js"></script>
  </body>
</html>